using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;

namespace PipLib.Mod
{
    /// <summary>
    /// The main abstract PipLib mod.
    /// </summary>
    public abstract class PipMod : IPipMod
    {

        [AttributeUsage(AttributeTargets.Class)]
        public sealed class ModInfo : Attribute
        {

            public readonly string Name;

            public Type Options { get; set; }

            public string Prefix { get; set; }

            public ModInfo(string name)
            {
                Name = name;
            }

        }

        public enum Step
        {
            /// <summary>
            /// Mod is initially loaded, akin to <c>OnLoad</c>.
            /// </summary>
            /// <value></value>
            Load,

            /// <summary>
            /// All mods have been loaded but the game has not started yet
            /// </summary>
            /// <value></value>
            PostLoad,

            /// <summary>
            /// Just before <see cref="Db.Initialize"/>
            /// </summary>
            /// <value></value>
            PreInitialize,

            /// <summary>
            /// Just after <see cref="Db.Initialize"/>
            /// </summary>
            /// <value></value>
            Initialize,

            /// <summary>
            /// After all mods have completed <see cref="Initialize"/>
            /// </summary>
            /// <value></value>
            PostInitialize,

            /// <summary>
            /// After the mod has been instanciated.
            /// </summary>
            PostInstanciate
        }

        [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
        public sealed class OnStep : Attribute
        {
            public Step Step { get; private set;}

            public OnStep (Step step)
            {
                Step = step;
            }
        }

        [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
        public class TypeCollector : Attribute
        {
            public static bool IsImpl (Type parent, Type type)
            {
                return parent.IsAssignableFrom(type) && type.IsClass && !type.IsAbstract;
            }

            public Type Predicate { get; private set; }

            public bool CaptureNonPipTypes { get; set; }

            public TypeCollector (Type predicate)
            {
                Predicate = predicate;
                CaptureNonPipTypes = false;
            }
        }

        public abstract string Name { get; }
        public virtual string Prefix { get; private set; }
        public virtual Type OptionsType { get; private set; }

        public Version Version { get; }
        public Logging.ILogger Logger { get; private set; }

        public PipMod()
        {
            Version = GetType().Assembly.GetName().Version;
            Logger = Logging.GlobalLogger.Get().Fork(Prefix ?? Name ?? GetType().Name);
            if (Prefix == null)
            {
                Prefix = Name;
            }
        }

        protected void RegisterOptions (Type options)
        {
            OptionsType = options;
            // POptions.RegisterOptions(options);
        }

        /* protected T ReadOptions<T> () where T : class
        {
            return POptions.ReadSettings<T>();
        } */

        public virtual void Load()
        {

        }

        public virtual void PostLoad()
        {

        }

        public virtual void PreInitialize()
        {

        }

        public virtual void Initialize()
        {

        }

        public virtual void PostInitialize()
        {

        }

        /// <summary>
        /// Creates multiple tags in bulk
        /// </summary>
        /// <param name="tags">The tags to create</param>
        public void CreateTags(params string[] tags)
        {
            foreach (var tag in tags)
            {
                CreateTag(tag);
            }
        }
        /// <summary>
        /// Creates a new substance tag with the given name and an optional proper name
        /// </summary>
        /// <param name="tag">The tag name</param>
        /// <param name="properName">The tag's proper name, if any</param>
        public void CreateTag(string tag, string properName = null)
        {
            if (properName != null)
            {
                Logger.Info("Create tag: {0} ({1}}", properName, tag);
                TagManager.Create(tag, properName);
            }
            else
            {
                Logger.Info("Create tag: {0}", tag);
                TagManager.Create(tag);
            }
        }

        public override string ToString()
        {
            return Name;
        }

        public override bool Equals(object obj)
        {
            return obj is PipMod mod &&
                   Name == mod.Name;
        }

        public override int GetHashCode()
        {
            // generated by Visual Studio
            return 363513814 + EqualityComparer<string>.Default.GetHashCode(Name);
        }
    }
}
